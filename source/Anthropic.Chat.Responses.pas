unit Anthropic.Chat.Responses;

{-------------------------------------------------------------------------------

      Github repository :  https://github.com/MaxiDonkey/DelphiAnthropic
      Visit the Github repository for the documentation and use examples

 ------------------------------------------------------------------------------}

interface

uses
  System.SysUtils, System.Classes,  System.JSON,
  REST.JsonReflect, REST.Json.Types,
  Anthropic.API, Anthropic.API.Params, Anthropic.Types, Anthropic.API.Streams,
  Anthropic.Chat.Beta, Anthropic.API.JsonSafeReader,
  Anthropic.Async.Support, Anthropic.Async.Promise;

type
  TContentBlock = class;

  TContentBlockContent = record
  private
    FOwner: TContentBlock;
  public
    constructor Create(AOwner: TContentBlock);

    { Tool result blocks (shortcuts) }
    function WebFetch: TWebFetchToolResultBlockContent;
    function WebSearch: TWebSearchToolResultBlock;
    function CodeExecution: TCodeExecutionToolResultBlock;
    function BashCodeExecution: TBashCodeExecutionToolResultBlock;
    function TextEditorCodeExecution: TTextEditorCodeExecutionToolResultBlock;
    function ToolSearch: TToolSearchToolResultBlock;
    function McpToolResult: TMcpToolResultBlock;
    function McpText: string;
    function McpIsText: Boolean;
  end;

  {$REGION '[beta]'}

   TCaller = class
   private
     FType: string;
     [JsonNameAttribute('tool_id')]
     FToolId: string;
   public
     /// <summary>
     /// <para>
     /// • direct : Tool invocation directly from the model.
     /// </para>
     /// <para>
     /// • code_execution_20250825 : Tool invocation generated by a server-side tool.
     /// </para>
     /// </summary>
     property &Type: string read FType write FType;

     property ToolId: string read FToolId write FToolId;
   end;

  {$ENDREGION}

  TContentBlock = class
  private
    [JsonReflectAttribute(ctString, rtString, TContentBlockTypeInterceptor)]
    FType: TContentBlockType;
    FCitations: TArray<TTextCitation>;

    [JSONMarshalled(False)]
    FRawContent: string;

    [JSONMarshalled(False)]
    FToolContent: TToolContent;

    FData: string;
    FId: string;
    [JsonReflectAttribute(ctString, rtString, TArgsFixInterceptor)]
    FInput: string;
    FName: string;
    FSignature: string;
    FText: string;
    FThinking: string;
    [JsonNameAttribute('tool_use_id')]
    FToolUseId: string;

    {$REGION '[beta]'}

    FCaller: TCaller;
    [JsonNameAttribute('server_name')]
    FServerName: string;
    [JsonNameAttribute('is_error')]
    FIsError: Boolean;
    [JsonNameAttribute('file_id')]
    FFileId: string;

    {$ENDREGION}

    function GetContent: TContentBlockContent;

  public
    property &Type: TContentBlockType read FType write FType;
    property Citations: TArray<TTextCitation> read FCitations write FCitations;
    property Content: TContentBlockContent read GetContent;
    property Data: string read FData write FData;
    property Id: string read FId write FId;
    property Input: string read FInput write FInput;
    property Name: string read FName write FName;
    property RawContent: string read FRawContent write FRawContent;
    property Signature: string read FSignature write FSignature;
    property Text: string read FText write FText;
    property Thinking: string read FThinking write FThinking;
    property ToolUseId: string read FToolUseId write FToolUseId;

    {$REGION '[beta]'}

    property Caller: TCaller read FCaller write FCaller;
    property FileId: string read FFileId write FFileId;
    property IsError: Boolean read FIsError write FIsError;
    property ServerName: string read FServerName write FServerName;

    property ToolContent: TToolContent read FToolContent write FToolContent;

    {$ENDREGION}

    procedure HydratePolymorphicContent(const Root: TJsonReader; const BlockPath: string);

    destructor Destroy; override;
  end;

  TCacheCreation = class
  private
    [JsonNameAttribute('ephemeral_1h_input_tokens')]
    FEphemeral1hInputTokens: Double;
    [JsonNameAttribute('ephemeral_5m_input_tokens')]
    FEphemeral5mInputTokens: Double;
  public
    /// <summary>
    /// The number of input tokens used to create the 1 hour cache entry.
    /// </summary>
    property Ephemeral1hInputTokens: Double read FEphemeral1hInputTokens write FEphemeral1hInputTokens;

    /// <summary>
    /// The number of input tokens used to create the 5 minute cache entry.
    /// </summary>
    property Ephemeral5mInputTokens: Double read FEphemeral5mInputTokens write FEphemeral5mInputTokens;
  end;

  TIterationUsage = class
  private
    [JsonNameAttribute('cache_creation')]
    FCacheCreation: TCacheCreation;
    [JsonNameAttribute('cache_creation_input_tokens')]
    FCacheCreationInputTokens: Double;
    [JsonNameAttribute('cache_read_input_tokens')]
    FCacheReadInputTokens: Double;
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Double;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Double;
    FType: string;
  public
    /// <summary>
    /// Breakdown of cached tokens by TTL
    /// </summary>
    property CacheCreation: TCacheCreation read FCacheCreation write FCacheCreation;

    /// <summary>
    /// The number of input tokens used to create the cache entry.
    /// </summary>
    property CacheCreationInputTokens: Double read FCacheCreationInputTokens write FCacheCreationInputTokens;

    /// <summary>
    /// The number of input tokens read from the cache.
    /// </summary>
    property CacheReadInputTokens: Double read FCacheReadInputTokens write FCacheReadInputTokens;

    /// <summary>
    /// The number of input tokens which were used.
    /// </summary>
    property InputTokens: Double read FInputTokens write FInputTokens;

    /// <summary>
    /// The number of output tokens which were used.
    /// </summary>
    property OutputTokens: Double read FOutputTokens write FOutputTokens;

    /// <summary>
    /// Usage for a sampling iteration "message" or Usage for a compaction iteration "compaction"
    /// </summary>
    property &Type: string read FType write FType;

    destructor Destroy; override;
  end;

  TServerToolUsage = class
  private
    [JsonNameAttribute('web_fetch_requests')]
    FWebFetchRequests: Double;
    [JsonNameAttribute('web_search_requests')]
    FWebSearchRequests: Double;
  public
    /// <summary>
    /// The number of web fetch tool requests.
    /// </summary>
    property WebFetchRequests: Double read FWebFetchRequests write FWebFetchRequests;

    /// <summary>
    /// The number of web search tool requests.
    /// </summary>
    property WebSearchRequests: Double read FWebSearchRequests write FWebSearchRequests;
  end;

  TUsage = class
  private
    [JsonNameAttribute('cache_creation')]
    FCacheCreation: TCacheCreation;
    [JsonNameAttribute('cache_creation_input_tokens')]
    FCacheCreationInputTokens: Double;
    [JsonNameAttribute('cache_read_input_tokens')]
    FCacheReadInputTokens: Double;
    [JsonNameAttribute('inference_geo')]
    FInferenceGeo: string;
    [JsonNameAttribute('input_tokens')]
    FInputTokens: Double;
    FIterations: TArray<TIterationUsage>;
    [JsonNameAttribute('output_tokens')]
    FOutputTokens: Double;
    [JsonNameAttribute('server_tool_use')]
    FServerToolUse: TServerToolUsage;
    [JsonNameAttribute('service_tier')]
    FServiceTier: string;
    FSpeed: string;
  public
    /// <summary>
    /// Breakdown of cached tokens by TTL
    /// </summary>
    property CacheCreation: TCacheCreation read FCacheCreation write FCacheCreation;

    /// <summary>
    /// The number of input tokens used to create the cache entry.
    /// </summary>
    property CacheCreationInputTokens: Double read FCacheCreationInputTokens write FCacheCreationInputTokens;

    /// <summary>
    /// The number of input tokens read from the cache.
    /// </summary>
    property CacheReadInputTokens: Double read FCacheReadInputTokens write FCacheReadInputTokens;

    /// <summary>
    /// The geographic region where inference was performed for this request.
    /// </summary>
    property InferenceGeo: string read FInferenceGeo write FInferenceGeo;

    /// <summary>
    /// The number of input tokens which were used.
    /// </summary>
    property InputTokens: Double read FInputTokens write FInputTokens;

    /// <summary>
    /// Per-iteration token usage breakdown.
    /// </summary>
    /// <remarks>
    /// Each entry represents one sampling iteration, with its own input/output token counts and cache
    ///statistics. This allows you to:
    /// <para>
    /// • Determine which iterations exceeded long context thresholds (>=200k tokens)
    /// </para>
    /// <para>
    /// • Calculate the true context window size from the last iteration
    /// </para>
    /// <para>
    /// • Understand token accumulation across server-side tool use loops
    /// </para>
    /// </remarks>
    property Iterations: TArray<TIterationUsage> read FIterations write FIterations;

    /// <summary>
    /// The number of output tokens which were used.
    /// </summary>
    property OutputTokens: Double read FOutputTokens write FOutputTokens;

    /// <summary>
    /// The number of server tool requests.
    /// </summary>
    property ServerToolUse: TServerToolUsage read FServerToolUse write FServerToolUse;

    /// <summary>
    /// If the request used the priority, standard, or batch tier.
    /// </summary>
    /// <remarks>
    /// Accepts one of the following: "standard", "priority" and "batch"
    /// </remarks>
    property ServiceTier: string read FServiceTier write FServiceTier;

    /// <summary>
    /// The inference speed mode used for this request.
    /// </summary>
    property Speed: string read FSpeed write FSpeed;

    destructor Destroy; override;
  end;

{$REGION '[beta]'}

  TSkill = class
  private
    [JsonNameAttribute('skill_id')]
    FSkillId: string;
    FType: string;
    FVersion: string;
  public
    property SkillId: string read FSkillId write FSkillId;
    property &Type: string read FType write FType;

    /// <summary>
    /// Skill version or 'latest' for most recent version
    /// </summary>
    /// <remarks>
    /// maxLength 64, minLength 1
    /// </remarks>
    property Version: string read FVersion write FVersion;
  end;

  TContainer = class
  private
    FId: string;
    [JsonNameAttribute('expires_at')]
    FExpiresAt: string;
    FSkills: TArray<TSkill>;
  public
    property Id: string read FId write FId;

    /// <summary>
    /// The time at which the container will expire.
    /// </summary>
    property ExpiresAt: string read FExpiresAt write FExpiresAt;

    /// <summary>
    /// Skills loaded in the container
    /// </summary>
    property Skills: TArray<TSkill> read FSkills write FSkills;

    destructor Destroy; override;
  end;

  TAppliedEdit = class
  private
    FType: string;
    [JsonNameAttribute('cleared_input_tokens')]
    FClearedInputTokens: Int64;
    [JsonNameAttribute('cleared_tool_uses')]
    FClearedToolUses: Int64;
    [JsonNameAttribute('cleared_thinking_turns')]
    FClearedThinkingTurns: Int64;
  public
    property &Type: string read FType write FType;

    /// <summary>
    /// Number of input tokens cleared by this edit.
    /// </summary>
    /// <remarks>
    /// minimum 0
    /// </remarks>
    property ClearedInputTokens: Int64 read FClearedInputTokens write FClearedInputTokens;

    /// <summary>
    /// Number of tool uses that were cleared.
    /// </summary>
    /// <remarks>
    /// minimum 0
    /// </remarks>
    property ClearedToolUses: Int64 read FClearedToolUses write FClearedToolUses;

    /// <summary>
    /// Number of thinking turns that were cleared.
    /// </summary>
    /// <remarks>
    /// minimum 0
    /// </remarks>
    property ClearedThinkingTurns: Int64 read FClearedThinkingTurns write FClearedThinkingTurns;
  end;

  TContextManagement = class
  private
    [JsonNameAttribute('applied_edits')]
    FAppliedEdits: TArray<TAppliedEdit>;
  public
    /// <summary>
    /// List of context management edits that were applied.
    /// </summary>
    property AppliedEdits: TArray<TAppliedEdit> read FAppliedEdits write FAppliedEdits;

    destructor Destroy; override;
  end;

{$ENDREGION}

  TMessage = class(TJSONFingerprint)
  private
    FType: string;
    FId: string;
    FModel: string;
    [JsonReflectAttribute(ctString, rtString, TMessageRoleInterceptor)]
    FRole: TMessageRole;
    FContent: TArray<TContentBlock>;
    [JsonReflectAttribute(ctString, rtString, TStopReasonInterceptor)]
    [JsonNameAttribute('stop_reason')]
    FStopReason: TStopReason;
    [JsonNameAttribute('stop_sequence')]
    FStopSequence: string;
    FUsage: TUsage;

  {$REGION '[beta]'}
    FContainer : TContainer;
    [JsonNameAttribute('context_management')]
    FContextManagement: TContextManagement;
  {$ENDREGION}

  protected
    /// <summary>
    /// Updates and rebuilds polymorphic content structures after JSON deserialization.
    /// </summary>
    /// <remarks>
    /// <para>
    /// • This method is responsible for processing content fields that cannot be reliably handled by
    /// automatic RTTI-based deserialization, such as polymorphic or dynamically typed JSON nodes.
    /// </para>
    /// <para>
    /// • It is typically invoked as part of the post-deserialization lifecycle and relies on the
    /// JSONResponse property to extract and rebuild the appropriate internal content representations.
    /// </para>
    /// <para>
    /// • This method is not intended to be called directly by user code and should be considered an
    /// internal implementation detail of the deserialization process.
    /// </para>
    /// </remarks>
    procedure ContentUpdate; override;

    /// <summary>
    /// Executes internal post-deserialization processing for the current instance.
    /// </summary>
    /// <remarks>
    /// <para>
    /// • This method serves as a protected lifecycle hook that is invoked after the JSON payload has
    /// been fully deserialized, bound, and the JSONResponse property assigned.
    /// </para>
    /// <para>
    /// • It allows derived classes to perform additional internal initialization steps such as invoking
    /// ContentUpdate, StreamEventBuilder, or other class-specific post-processing logic.
    /// </para>
    /// <para>
    /// • This method is not intended to be called directly by user code and should be considered an
    /// internal extension point of the deserialization infrastructure.
    /// </para>
    /// </remarks>
    procedure AfterDeserialize; override;

  public
    /// <summary>
    /// Object type.
    /// </summary>
    /// <remarks>
    /// For Messages, this is always "message".
    /// </remarks>
    property &Type: string read FType write FType;

    /// <summary>
    /// Unique object identifier.
    /// </summary>
    /// <remarks>
    /// The format and length of IDs may change over time.
    /// </remarks>
    property Id: string read FId write FId;

    /// <summary>
    /// Information about the container used in the request (for the code execution tool)
    /// </summary>
    property Container : TContainer read FContainer write FContainer;

    /// <summary>
    /// Content generated by the model.
    /// </summary>
    /// <remarks>
    /// <para>
    /// • This is an array of content blocks, each of which has a type that determines its shape.
    /// </para>
    /// <para>
    /// • If the request input messages ended with an assistant turn, then the response content will
    /// continue directly from that last turn. You can use this to constrain the model's output.
    /// </para>
    /// </remarks>
    property Content: TArray<TContentBlock> read FContent write FContent;

    /// <summary>
    /// Context management response.
    /// </summary>
    /// <remarks>
    /// Information about context management strategies applied during the request.
    /// </remarks>
    property ContextManagement: TContextManagement read FContextManagement write FContextManagement;

    /// <summary>
    /// The model that will complete your prompt.
    /// </summary>
    property Model: string read FModel write FModel;

    /// <summary>
    /// Conversational role of the generated message.
    /// </summary>
    /// <remarks>
    /// This will always be "assistant".
    /// </remarks>
    property Role: TMessageRole read FRole write FRole;

    /// <summary>
    /// The reason that we stopped.
    /// </summary>
    /// <remarks>
    /// This may be one the following values:
    /// <para>
    /// • "end_turn": the model reached a natural stopping point
    /// </para>
    /// <para>
    /// • "max_tokens": we exceeded the requested max_tokens or the model's maximum
    /// </para>
    /// <para>
    /// • "stop_sequence": one of your provided custom stop_sequences was generated
    /// </para>
    /// <para>
    /// • "tool_use": the model invoked one or more tools
    /// </para>
    /// <para>
    /// • "pause_turn": we paused a long-running turn. You may provide the response
    /// back as-is in a subsequent request to let the model continue.
    /// </para>
    /// <para>
    /// • "refusal": when streaming classifiers intervene to handle potential policy violations
    /// </para>
    /// In non-streaming mode this value is always non-null. In streaming mode, it is null in
    /// the message_start event and non-null otherwise.
    /// </remarks>
    property StopReason: TStopReason read FStopReason write FStopReason;

    /// <summary>
    /// Which custom stop sequence was generated, if any.
    /// </summary>
    /// <remarks>
    /// This value will be a non-null string if one of your custom stop sequences was generated.
    /// </remarks>
    property StopSequence: string read FStopSequence write FStopSequence;

    /// <summary>
    /// Billing and rate-limit usage.
    /// </summary>
    /// <remarks>
    /// <para>
    /// • Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost
    /// to our systems.
    /// </para>
    /// <para>
    /// • Under the hood, the API transforms requests into a format suitable for the model. The model's
    /// output then goes through a parsing stage before becoming an API response. As a result, the token
    /// counts in usage will not match one-to-one with the exact visible content of an API request or
    /// response.
    /// </para>
    /// <para>
    /// • For example, output_tokens will be non-zero, even for an empty string response from Claude.
    /// </para>
    /// <para>
    /// • Total input tokens in a request is the summation of input_tokens, cache_creation_input_tokens,
    /// and cache_read_input_tokens.
    /// </para>
    /// </remarks>
    property Usage: TUsage read FUsage write FUsage;

    destructor Destroy; override;
  end;

{$REGION 'TokensCount'}

  {$REGION '[beta]'}

  TTokensCountContextManagement = class
  private
    [JsonNameAttribute('original_input_tokens')]
    FOriginalInputTokens: Int64;
  public
    /// <summary>
    /// The original token count before context management was applied
    /// </summary>
    property OriginalInputTokens: Int64 read FOriginalInputTokens write FOriginalInputTokens;
  end;

  {$ENDREGION}

  TTokenCount = class(TJSONFingerprint)
  private
    [JsonNameAttribute('context_management')]
    FContextManagement: TTokensCountContextManagement;

    [JsonNameAttribute('input_tokens')]
    FInputTokens: Int64;
  public
    /// <summary>
    /// Information about context management applied to the message.
    /// </summary>
    property ContextManagement: TTokensCountContextManagement read FContextManagement write FContextManagement;

    /// <summary>
    /// The total number of tokens across the provided list of messages, system prompt, and tools.
    /// </summary>
    property InputTokens: Int64 read FInputTokens write FInputTokens;

    destructor Destroy; override;
  end;

  /// <summary>
  /// Defines an asynchronous callback handler for token count responses.
  /// </summary>
  /// <remarks>
  /// <para>
  /// • <c>TAsynTokenCount</c> is a type alias for <c>TAsynCallBack&lt;TTokenCount&gt;</c>, specialized for
  /// handling token count results returned by token counting endpoints.
  /// </para>
  /// <para>
  /// • It binds the generic asynchronous callback infrastructure to the token counting domain by
  /// fixing the callback payload type to <c>TTokenCount</c>.
  /// </para>
  /// <para>
  /// • This alias improves readability and intent expression in public APIs while preserving the
  /// complete behavior and lifecycle semantics of <c>TAsynCallBack&lt;TTokenCount&gt;</c>.
  /// </para>
  /// <para>
  /// • Use <c>TAsynTokenCount</c> when registering callbacks that consume token count responses without
  /// blocking the calling thread.
  /// </para>
  /// </remarks>
  TAsynTokenCount = TAsynCallBack<TTokenCount>;

  /// <summary>
  /// Defines a promise-based callback handler for token count responses.
  /// </summary>
  /// <remarks>
  /// <para>
  /// • <c>TPromiseTokenCount</c> is a type alias for <c>TPromiseCallback&lt;TTokenCount&gt;</c>, specialized
  /// for consuming token count results returned by token counting endpoints.
  /// </para>
  /// <para>
  /// • It binds the generic promise-based callback infrastructure to the token counting domain by
  /// fixing the callback payload type to <c>TTokenCount</c>.
  /// </para>
  /// <para>
  /// • This alias improves API clarity by explicitly expressing promise-oriented consumption semantics
  /// while preserving the complete behavior of <c>TPromiseCallback&lt;TTokenCount&gt;</c>.
  /// </para>
  /// <para>
  /// • Use <c>TPromiseTokenCount</c> when consuming token count responses through promise-based
  /// abstractions instead of direct callbacks.
  /// </para>
  /// </remarks>
  TPromiseTokenCount = TPromiseCallback<TTokenCount>;

{$ENDREGION}

  /// <summary>
  /// Represents a chat message returned by the chat completion endpoint.
  /// </summary>
  /// <remarks>
  /// <para>
  /// • <c>TChat</c> is a chat-specific specialization of <c>TMessage</c> that models a fully materialized
  /// chat response once streaming or message assembly has completed.
  /// </para>
  /// <para>
  /// • It inherits all structural components of <c>TMessage</c>, including role information, content
  /// blocks, and associated metadata, without introducing additional state.
  /// </para>
  /// <para>
  /// • This class exists to provide a semantically explicit type for chat responses, improving API
  /// clarity and intent expression in consumer code.
  /// </para>
  /// <para>
  /// • Use <c>TChat</c> when working with non-streamed chat responses or with fully aggregated messages
  /// reconstructed from streaming events.
  /// </para>
  /// </remarks>
  TChat = class(TMessage);

  /// <summary>
  /// Defines an asynchronous callback handler for chat responses.
  /// </summary>
  /// <remarks>
  /// <para>
  /// • <c>TAsynChat</c> is a type alias for <c>TAsynCallBack&lt;TChat&gt;</c>, specialized for handling
  /// fully materialized chat responses.
  /// </para>
  /// <para>
  /// • It binds the generic asynchronous callback infrastructure to the chat domain by fixing the
  /// callback payload type to <c>TChat</c>.
  /// </para>
  /// <para>
  /// • This alias improves readability and intent expression in public APIs while preserving the
  /// complete behavior and lifecycle semantics of <c>TAsynCallBack&lt;TChat&gt;</c>.
  /// </para>
  /// <para>
  /// • Use <c>TAsynChat</c> when registering callbacks that consume non-streamed or fully aggregated
  /// chat responses.
  /// </para>
  /// </remarks>
  TAsynChat = TAsynCallBack<TChat>;

  /// <summary>
  /// Defines a promise-based callback handler for chat responses.
  /// </summary>
  /// <remarks>
  /// <para>
  /// • <c>TPromiseChat</c> is a type alias for <c>TPromiseCallback&lt;TChat&gt;</c>, specialized for
  /// consuming fully materialized chat responses.
  /// </para>
  /// <para>
  /// • It binds the generic promise-based callback infrastructure to the chat domain by fixing the
  /// callback payload type to <c>TChat</c>.
  /// </para>
  /// <para>
  /// • This alias improves API clarity by explicitly expressing promise-oriented consumption semantics
  /// while preserving the complete behavior of <c>TPromiseCallback&lt;TChat&gt;</c>.
  /// </para>
  /// <para>
  /// • Use <c>TPromiseChat</c> when consuming non-streamed or fully aggregated chat responses through
  /// promise-based abstractions.
  /// </para>
  /// </remarks>
  TPromiseChat = TPromiseCallback<TChat>;

implementation

{ TUsage }

destructor TUsage.Destroy;
begin
  if Assigned(FCacheCreation) then
    FCacheCreation.Free;
  if Assigned(FServerToolUse) then
    FServerToolUse.Free;
  for var Item in FIterations do
    Item.Free;
  inherited;
end;

{ TMessage }

procedure TMessage.AfterDeserialize;
begin
  inherited;
  ContentUpdate;
end;

procedure TMessage.ContentUpdate;
begin
  inherited;

  var Root := TJsonReader.Parse(JSONResponse);

  {--- Only iterate blocks that actually have a "content" field (content[i].content exists) }
  var Indices := Root.IndicesWithFieldInArray('content', 'content');

  for var Index in Indices do
    begin
      if (Index < 0) or (Index > High(Content)) then
        Continue;

      Content[Index].HydratePolymorphicContent(Root, Format('content[%d]', [Index]));
    end;
end;

destructor TMessage.Destroy;
begin
  for var Item in FContent do
    Item.Free;
  if Assigned(FUsage) then
    FUsage.Free;

  if Assigned(FContainer) then
    FContainer.Free;
  if Assigned(FContextManagement) then
    FContextManagement.Free;
  inherited;
end;

{ TContentBlock }

destructor TContentBlock.Destroy;
begin
  if Assigned(FToolContent) then
    FToolContent.Free;
  for var Item in FCitations do
    Item.Free;
  inherited;
end;

function TContentBlock.GetContent: TContentBlockContent;
begin
  Result := TContentBlockContent.Create(Self);
end;

procedure TContentBlock.HydratePolymorphicContent(const Root: TJsonReader;
  const BlockPath: string);
const
  PATTERN = '{"content":%s}';
var
  Payload: string;
begin
  {--- Nothing to do if we don't have a root or a path }
  if (not Root.IsValid) or BlockPath.IsEmpty then
    Exit;

  var TargetPath := BlockPath + '.content';

  {--- If the node doesn't exist at all => no-op (e.g. server_tool_use) }
  if Root.Value(TargetPath) = nil then
    Exit;

  {--- Extract raw JSON content (string value is returned de-quoted by ExtractSubJson) }
  var Raw := Root.ExtractSubJson(TargetPath, '');

  {--- Build payload compatible with TToolContent.OverloadBuilder }
  if Root.IsStringNode(TargetPath) then
    begin
      var JSONString := TJSONString.Create(Raw);
      try
        Payload := Format(PATTERN, [JSONString.ToJSON]);
      finally
        JSONString.Free;
      end;
    end
  else
    Payload := Format(PATTERN, [Raw]);

  {--- Persist raw + typed tool content }
  Self.RawContent := Raw;
  Self.ToolContent := TToolContent.OverloadBuilder(Payload, Self.&Type);
end;

{ TContainer }

destructor TContainer.Destroy;
begin
  for var Item in FSkills do
    Item.Free;
  inherited;
end;

{ TContextManagement }

destructor TContextManagement.Destroy;
begin
  for var Item in FAppliedEdits do
    Item.Free;
  inherited;
end;

{ TContentBlockContent }

constructor TContentBlockContent.Create(AOwner: TContentBlock);
begin
  FOwner := AOwner;
end;

function TContentBlockContent.WebFetch: TWebFetchToolResultBlockContent;
begin
  Result := FOwner.ToolContent.WebFetchToolResultBlock.Content;
end;

function TContentBlockContent.WebSearch: TWebSearchToolResultBlock;
begin
  Result := FOwner.ToolContent.WebSearchToolResultBlock;
end;

function TContentBlockContent.CodeExecution: TCodeExecutionToolResultBlock;
begin
  Result := FOwner.ToolContent.CodeExecutionToolResultBlock;
end;

function TContentBlockContent.BashCodeExecution: TBashCodeExecutionToolResultBlock;
begin
  Result := FOwner.ToolContent.BashCodeExecutionToolResultBlock;
end;

function TContentBlockContent.TextEditorCodeExecution: TTextEditorCodeExecutionToolResultBlock;
begin
  Result := FOwner.ToolContent.TextEditorCodeExecutionToolResultBlock;
end;

function TContentBlockContent.ToolSearch: TToolSearchToolResultBlock;
begin
  Result := FOwner.ToolContent.ToolSearchToolResultBlock;
end;

function TContentBlockContent.McpIsText: Boolean;
begin
  if (FOwner = nil) or (FOwner.ToolContent = nil) then
    Exit(False);

  Result := FOwner.ToolContent.MCPToolResultBlock.HasValue and
            SameText(FOwner.ToolContent.MCPToolResultBlock.&Type, 'text');
end;

function TContentBlockContent.McpText: string;
begin
  if not McpIsText then
    Exit(EmptyStr);

  var MCP := FOwner.ToolContent.MCPToolResultBlock;
  Result := MCP.StringContent;
end;

function TContentBlockContent.McpToolResult: TMcpToolResultBlock;
begin
  Result := FOwner.ToolContent.MCPToolResultBlock;
end;

{ TTokenCount }

destructor TTokenCount.Destroy;
begin
  if Assigned(FContextManagement) then
    FContextManagement.Free;
  inherited;
end;

{ TIterationUsage }

destructor TIterationUsage.Destroy;
begin
  if Assigned(FCacheCreation) then
    FCacheCreation.Free;
  inherited;
end;

end.
